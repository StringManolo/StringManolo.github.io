import * as std from "std";
 
const cli = {};
cli.dest = [];
for (let i in scriptArgs) {
  const value = scriptArgs[+i + 1];
  switch(scriptArgs[i]) {
    case "-c":
    case "-cpp":
    case "-c++":
    case "--cpp":
    case "--c++":
    case "--cplusplus":
      cli.dest.push("cpp");
    break;

    case "-j":
    case "-js":
    case "--js":
    case "--javascript":
      cli.dest.push("javascript");
    break;

    case "-f":
    case "--file":
      cli.code = std.loadFile(value);
    break;

    case "-o":
    case "--output":
      cli.output = value;
    break;
  }
}

if(!cli.code) {
  console.log("You need to provide source code path/filename using -f argument.");
  exit(0);
}

const isIn = (str, arr) => {
  for(let i in arr) {
    if(str === arr[i]) {
      return true;
    }
  }
  return false;
}


/* If user chose to compile to cpp */
if ( isIn("cpp", cli.dest) ) {
  console.log("Transpilling to cpp...");

/* simple.h is hardcoded into cli util. */
const simple_h = `/* THIS CODE IS GENERATED BY SIMPLE2.js CLI TOOL */

#include <iostream>
#include <array>
#include <string>
#include <any>


using namespace std;

template <typename... Args>
int add(Args... args) {
  int res = 0;
  for(const auto i : {args...}) {
    res += i;
  }
  return res;
}

template <typename... Args>
int sub(Args... args) {
  int res = 0;
  int counter = 0;
  for(const auto i : {args...}) {
    if (counter == 0) {
      res = i * 2;
      ++counter;
    }
    res -= i;
  }
  return res;
}

template <typename... Args>
int mul(Args... args) {
  int res = 0;
  int counter = 0;
  for(const auto i : {args...}) {
    if (counter == 0) {
      res = i;
      ++counter;
    } else {
      res *= i;
    }
  }
  return res;
}

template <typename... Args>
int div(Args... args) {
  int res = 0;
  int counter = 0;
  for(const auto i : {args...}) {
    if (counter == 0) {
      res = i;
      ++counter;
    } else {
      res /= i;
    }
  }
  return res;
}

template <typename... Args>
int mod(Args... args) {
  int res = 0;
  int counter = 0;
  for(const auto i : {args...}) {
    if (counter == 0) {
      res = i;
      ++counter;
    } else {
      res %= i;
    }
  }
  return res;
}


auto fun(string expr) {
  /* This function is hard to implement directly in C/C++.
  Instead of write cpp code herehere  i preprocess it in Simple2Cpp cli command to generate the code in compilation/transpilling time */

  return 0;
}

struct Console
{

template <typename ...Ts>
static void log(Ts&&... ts)
{
    (do_log(ts), ...);
    std::cout << "\\n";
}

// private:
template <typename T>
static void do_log(const T& arg) {
    std::cout << arg;
}

template <typename T>
static void do_log(const std::vector<T>& v)
{
    std::cout << '{';

    const char* sep = "";
    for (const auto& e : v) {
        std::cout << sep;
        do_log(e);
        sep = ", ";
    }
    std::cout << '}';
}

template <typename T>
static bool try_log_any(const std::any& arg) {
    if (auto* p = std::any_cast<T>(&arg)) {
        do_log(*p);
        return true;
    }
    return false;
}

template <typename... Ts>
static bool try_log_any_from(const std::any& arg) {
    if ((try_log_any<Ts>(arg) || ...)) {
        return true;
    }

    auto t = arg;
    try {
        std::any_cast<std::string>(t);
        std::cout /* ANY */<< std::any_cast<std::string>(t) << std::endl;
      } catch (const std::bad_any_cast& a) {
        //std::cout << a.what() << '\\n';
        try {
          std::any_cast<int>(t);
          std::cout /* ANY */<< std::any_cast<int>(t) << std::endl;
        } catch (const std::bad_any_cast& b) {
          try {
            std::any_cast<bool>(t);
            std::cout /* ANY */<< std::any_cast<bool>(t) << std::endl;
          } catch (const std::bad_any_cast& c) {
            try {
              std::any_cast<short int>(t);
              std::cout /* ANY */<< std::any_cast<short int>(t) << std::endl;
            } catch (const std::bad_any_cast& d) {
              try {
                std::any_cast<unsigned short int>(t);
                std::cout /* ANY */<< std::any_cast<unsigned short int>(t) << std::endl;
              } catch (const std::bad_any_cast& e) {
                try {
                  std::any_cast<unsigned int>(t);
                  std::cout /* ANY */<< std::any_cast<unsigned int>(t) << std::endl;
                } catch (const std::bad_any_cast& f) {
                  try {
                    std::any_cast<long int>(t);
                    std::cout /* ANY */<< std::any_cast<long int>(t) << std::endl;
                  } catch (const std::bad_any_cast& g) {
                    try {
                      std::any_cast<unsigned long int>(t);
                      std::cout /* ANY */<< std::any_cast<unsigned long int>(t) << std::endl;
                    } catch (const std::bad_any_cast& h) {
                      try {
                        std::any_cast<long long int>(t);;
                        std::cout /* ANY */<< std::any_cast<long long int>(t) << std::endl;
                      } catch (const std::bad_any_cast& i) {
                        try {
                          std::any_cast<unsigned long long int>(t);
                          std::cout /* ANY */<< std::any_cast<unsigned long long int>(t) << std::endl;
                        } catch (const std::bad_any_cast& j) {
                          try {
                            std::any_cast<float>(t);
                            std::cout /* ANY */<< std::any_cast<float>(t) << std::endl;
                          } catch (const std::bad_any_cast& k) {
                            try {
                              std::any_cast<double>(t);
                              std::cout /* ANY */<< std::any_cast<double>(t) << std::endl;
                            } catch (const std::bad_any_cast& l) {
                              try {
                                std::any_cast<char>(t);
                                std::cout /* ANY */<< std::any_cast<char>(t) << std::endl;
                              } catch (const std::bad_any_cast& m) {
                                try {
                                  std::any_cast<unsigned char>(t);
                                  std::cout /* ANY */<< std::any_cast<unsigned char>(t) << std::endl;
                                } catch (const std::bad_any_cast& n) {
                                  try {
                                    std::any_cast<wchar_t>(t);
                                    std::cout /* ANY */<< std::any_cast<wchar_t>(t) << std::endl;
                                  } catch (const std::bad_any_cast& o) {
                                    try {
                                      std::any_cast<const char*>(t);
                                      std::cout /* ANY */<< std::any_cast<const char*>(t) << std::endl;

                                    } catch (const std::bad_any_cast& p) {
                                      std::cout << a.what() << '\\n';
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    return false;
}

static void do_log(const std::any& arg) {
    try_log_any_from<std::string, int, unsigned, char, float, double /*..*/>(arg);
}
};

Console console;


template <typename... Args>
bool equ(Args... args) {
  bool res = true;
  int argsLength = 0;

  /* Iterate the args because i don't know how to get the number of args in call. Ugly i know. */
  for(const auto i : {args...}) {
    ++argsLength;
  }


  for(const auto i : {args...}) {
    if(i + 1 >= argsLength) {
      return res;
    }
    if (i != res) {
      res = false;
    }
  }
  return res;
}`;

  let code = cli.code;
  let aux = "";
  const firstCommaFromPos = (pos, str) => {
    for (; pos < str.length; ++pos) {
      if (str[+pos] !== "\\" && str[+pos + 1] === '"') {
        return +pos + 1;
      } 
    }
    return "not found";
  }


  let expr = cli.code.split("\n");
  for(let i in expr) {
    if (/fun/.test(expr[i]) ) {
      const fun = expr[i].split("fun");
      for (let i in fun) {
        fun[i] = fun[i].replaceAll(" ", "");
        if (fun[i].charAt(0) === "(" && fun[i].charAt(1) === '"') {
          const endPos = firstCommaFromPos(2, fun[i]);
          if (endPos === "not found") {
            break;
          } 
          const fullExpr = fun[i].substr(2, endPos - 2);
          console.log("FullExpr: " + fullExpr);

          const id = fullExpr.split(":")[0];
          let value = fullExpr.split(":").splice(1).toString();
          let valueInLines = value.split("\n");
          if (valueInLines.length < 2) {
            value = "return " + value;
          } 

          if (value.charAt(value.length) !== ";") {
            value += ";";
          }
          aux += `\n\nint ${id}() {
  ${value}
}\n\n`;
        } 

      }
      /* if ("(" === expr[i].split("fun(")[1].trim()[0]) {
        // TODO: TEST IF FUN( IS INSIDE COMMENT OT STRING
        
      } */
    }
  }
  code = `${ simple_h || std.loadFile("simple.h")}

${aux}

int main() {
${cli.code}
  return 0;
}\n`;

  if (cli.output) {
    const fd = std.open(cli.output + ".cpp", "w");
    fd.puts(code);
    fd.close(); 
  } else {
    console.log(code);
  }
}


/* If user chose to compile to js */
if ( isIn("javascript", cli.dest) ) {
  console.log("Transpiling to javascript...");
/* simple.js is hardcoded here */
  const simple_js = `/* THIS CODE IS GENERATED BY SIMPLE2.js CLI TOOL */

const add = (...args) => {
  let res = args[0];
  for(let i = 1; i < args.length; ++i) {
    res += args[i];
  }
  return res;
}

const sub = (...args) => {
  let res = args[0];
  for(let i = 1; i < args.length; ++i) {
    res -= args[i];
  }
  return res;
}

const mul = (...args) => {
  let res = args[0];
  for(let i = 1; i < args.length; ++i) {
    res *= args[i];
  }
  return res;
}

const div = (...args) => {
  let res = args[0];
  for(let i = 1; i < args.length; ++i) {
    res /= args[i];
  }
  return res;
}

const mod = (...args) => {
  let res = args[0];
  for(let i = 1; i < args.length; ++i) {
    res %= args[i];
  }
  return res;
}

const fun = expr => {
  let [id, code] = expr.split(":");

  /* Omit return if 1 line of code and not return found */
  if (code.split("\\n").length < 2) {
    code = new RegExp("return", "g").test(code) ? code : "return " + code;
  }

  globalThis[id] = new Function(code);
  return 0;
}

const equ = (...args) => {
  let res = true;
  for(let i = 0; i < args.length; ++i) {
    if (+i + 1 >= args.length) {
      return +res;
    }
    if (args[i] === (args[+i + 1] || true) ) {
      if (res) {
        res = true;
      }
    } else {
      res = false;
    }
  }
  return +res;
}

const str = text => "" + text;

const defs = {};

const set = (id, value) => {
  globalThis[id] = value;
  return 0;
}`;


  let code = `${ simple_js || std.loadFile("simple.js")}

${cli.code}

`;

  if (cli.output) {
    const fd = std.open(cli.output + ".js", "w");
    fd.puts(code);
    fd.close();
  } else {
    console.log(code);
  }

}


console.log("\nDone.");
